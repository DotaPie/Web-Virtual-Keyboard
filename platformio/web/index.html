<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Web Virtual Keyboard</title>

<style>
:root {
	--bg: #121315;
	--text: #f1f3f5;
	--muted: #a8acb3;
	--card: #1b1c20;
	--border: #2b2d33;

	--accent-1: #ff7a18;
	--accent-2: #ffa24d;

	--ok: #9de19d;
	--err: #ff8a8a;
	--warn: #f1c40f;

	--radius: 14px;
	--radius-sm: 10px;

	--gap: 10px;
	--pad: 18px;

	--fs-body: 16px;
	--fs-small: 14px;
}

* { box-sizing: border-box; }

body {
	margin: 0;
	background: var(--bg);
	color: var(--text);
	font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif;
	display: flex;
	justify-content: center;
	padding: 28px 16px;
}

h1 { margin: 0 0 14px; font-size: clamp(20px, 3.6vw, 32px); }
h2 { margin: 18px 0 10px; font-size: 18px; color: var(--muted); font-weight: 700; letter-spacing: .3px; }

.card {
	width: min(1200px, 95vw);
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: var(--pad);
}

.row { display: flex; flex-wrap: wrap; align-items: center; gap: var(--gap); }
.row + .row { margin-top: 10px; }

/* top input + Send button as grid */
.row--send {
	display: grid;
	grid-template-columns: 1fr;
	gap: 0;
	align-items: stretch;
}

/* NEW: hotkey buttons under the textarea */
.row--hotkeys {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
	gap: var(--gap);
}

/* 3 inputs + button on one line for desktop */
.row--form {
	display: grid;
	grid-template-columns:
		minmax(260px, 2fr)
		minmax(200px, 1.5fr)
		minmax(220px, 1.5fr)
		auto;
	gap: var(--gap);
	align-items: stretch;
}

/* No automatic ellipsis for the password cell */
.val--clip {
  text-overflow: clip !important;  /* override the .val ellipsis */
  overflow: hidden;                 /* keep truncation */
  white-space: nowrap;              /* single line */
  min-width: 0;                     /* allow shrinking in grid */
}

/* Inputs & textarea share styling */
input[type="text"], input[type="password"], textarea {
	padding: 10px 14px;
	font-size: var(--fs-body);
	color: var(--text);
	background: #141519;
	border: 1px solid var(--border);
	border-radius: var(--radius-sm);
	outline: none;
	transition: border-color .15s, box-shadow .15s;
	min-width: 0;
	width: 100%;
}

input[type="text"], input[type="password"] { height: 48px; }

textarea {
	min-height: 96px;   /* 4 rows-ish */
	resize: vertical;   /* allow vertical resize */
	line-height: 1.35;
}

input[type="text"]:focus, input[type="text"]:hover,
input[type="password"]:focus, input[type="password"]:hover,
textarea:focus, textarea:hover {
	border-color: var(--accent-1);
	box-shadow: 0 0 8px 2px rgba(255, 122, 24, .35);
}

input[type="checkbox"] { width: 20px; height: 20px; accent-color: var(--accent-1); cursor: pointer; }
.checkbox { display: inline-flex; align-items: center; gap: 8px; }

button {
	height: 48px; padding: 0 20px; border: 0; border-radius: var(--radius-sm);
	font-weight: 700; color: #101114; cursor: pointer;
	background: linear-gradient(180deg, var(--accent-1) 0%, var(--accent-2) 100%);
	transition: filter .15s, box-shadow .15s;
}

button:hover { filter: brightness(1.15); box-shadow: 0 0 14px 4px rgba(255,122,24,.6); }
button:active{ filter: brightness(1.05); }
button:disabled{ opacity: .65; cursor: not-allowed; }

.hr { height: 1px; background: var(--border); margin: 16px 0; }
.small { font-size: var(--fs-small); color: var(--muted); }
#msg { margin-top: 10px; font-size: var(--fs-small); color: var(--muted); min-height: 1.2em; }
#msg.ok{ color: var(--ok); } #msg.err{ color: var(--err);} #msg.warn{ color: var(--warn); }

.kv {
	display: grid;
	grid-template-columns: minmax(120px, 220px) 1fr;
	gap: 16px;
	align-items: center;
}
.kv .name { font-weight: 600; color: var(--text); word-break: break-word; }
.kv .vals {
	display: grid;
	grid-template-columns: 1fr 1fr max-content;
	gap: 12px;
	align-items: center;
	width: 100%;
}

.val {
	font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	min-width: 0;
}
.kv + .kv { border-top: 1px dashed var(--border); padding-top: 10px; margin-top: 10px; }

.btn-sm { height: 38px; padding: 0 14px; border-radius: 10px; }
.toggle {
	display: inline-block;
	text-decoration: underline;
	cursor: pointer;
	font-size: var(--fs-small);
	color: var(--muted);
	width: 4ch;
	text-align: left;
}

/* ---------- Responsive fixes ---------- */

/* Tablet & small laptop: stack preset rows and let buttons wrap */
@media (max-width: 900px) {
  .row--form { grid-template-columns: 1fr; }
  .kv { grid-template-columns: 1fr; align-items: start; }
  .kv .name { min-width: 0; }
  .kv .vals { grid-template-columns: 1fr; row-gap: 8px; }
  .kv .vals > div:last-child { flex-wrap: wrap; gap: 10px; }
}

/* Phone width: put the Send button under the textarea */
@media (max-width: 480px) {
  .row--send { grid-template-columns: 1fr; }
  .row--send #send { width: 100%; }
  .row--hotkeys { grid-template-columns: 1fr; } /* stack hotkeys */
}
</style>
</head>

<body>
<div class="card">
	<h1>Web Virtual Keyboard</h1>

	<!-- Wide multi-line box + Send -->
	<div class="row row--send">
		<textarea id="text" placeholder="Enter text here (Shift+Enter for newline, Enter to send)" autocomplete="off" autofocus></textarea>
	</div>

	<!-- NEW: Hotkey buttons directly below textbox -->
	<div class="row row--hotkeys" aria-label="Hotkey actions">
		<button id="send" type="button">Send</button>
		<button id="btnCtrlC" type="button" title="Send Ctrl+C">Ctrl-C</button>
		<button id="btnCtrlX" type="button" title="Send Ctrl+X">Ctrl-X</button>
		<button id="btnCtrlAltDel" type="button" title="Send Ctrl+Alt+Del">Ctrl-Alt-Del</button>
	</div>

	<div class="row">
		<label class="checkbox" for="appendNL">
			<input type="checkbox" id="appendNL" checked>
			<span>Auto press Enter</span>
		</label>
	</div>

	<div class="hr"></div>

	<h2>Manage Presets</h2>
	<div class="row row--form">
		<input id="pname" type="text" placeholder="Preset name" autocomplete="off">
		<input id="puser" type="text" placeholder="Username" autocomplete="off">
		<input id="ppass" type="password" placeholder="Password" autocomplete="new-password">
		<button id="addPreset" type="button">Add / Update</button>
	</div>

	<div class="row small">
		Presets are saved persistently in flash memory (username + password).
	</div>

	<div class="hr"></div>

	<!-- Presets list -->
	<div id="plist"></div>

	<div id="msg" aria-live="polite"></div>
</div>

<script>
const text   	= document.getElementById("text");
const msg    	= document.getElementById("msg");
const btn    	= document.getElementById("send");
const cbNL   	= document.getElementById("appendNL");
const pname  	= document.getElementById("pname");
const puser  	= document.getElementById("puser");
const ppass  	= document.getElementById("ppass");
const addBtn 	= document.getElementById("addPreset");
const plist  	= document.getElementById("plist");

/* NEW: hotkey buttons */
const btnCtrlC      = document.getElementById("btnCtrlC");
const btnCtrlX      = document.getElementById("btnCtrlX");
const btnCtrlAltDel = document.getElementById("btnCtrlAltDel");

/* NEW: control sequences (edit as needed for your backend) */
const CTRL_C = "\u0003";   // ETX
const CTRL_X = "\u0018";   // CAN

/* For Ctrl+Alt+Del, different backends use different signals.
   Replace CAD_SEQUENCE with what your server expects, e.g.:
   - a literal token like "{CTRL}{ALT}{DEL}"
   - a dedicated endpoint (then change sendRaw() URL)
   - a sentinel like "\u0000CAD" that your server maps
   - or ASCII DEL alone "\u007F" if that’s your device’s trigger
*/
const CAD_SEQUENCE = "{CTRL}{ALT}{DEL}";

function setMsg(t, cls) {
	msg.textContent = t;
	msg.className   = cls || "";
}

/* Existing text sender (respects Auto press Enter) */
async function sendText(value) {
	const newlineFlag = cbNL.checked ? "1" : "0";
	const body        = "text=" + encodeURIComponent(value) + "&newline=" + newlineFlag;

	setMsg("Sending ...", "");
	btn.disabled = true;

	try {
		const r = await fetch("/type", {
			method: "POST",
			headers: { "Content-Type": "application/x-www-form-urlencoded" },
			body
		});
		if (!r.ok) { throw new Error(); }
		setMsg("Text sent", "ok");

		text.value = "";
    	text.focus();
	} catch (e) {
		setMsg("Sending text failed", "err");
	} finally {
		btn.disabled = false;
	}
}

/* NEW: raw sender for hotkeys (IGNORES Auto press Enter) */
async function sendRaw(chars) {
	const body = "text=" + encodeURIComponent(chars) + "&newline=0";

	setMsg("Sending ...", "");
	// Temporarily disable only the hotkey buttons to prevent double taps
	const hotkeyButtons = [btnCtrlC, btnCtrlX, btnCtrlAltDel];
	hotkeyButtons.forEach(b => b.disabled = true);

	try {
		const r = await fetch("/type", {
			method: "POST",
			headers: { "Content-Type": "application/x-www-form-urlencoded" },
			body
		});
		if (!r.ok) { throw new Error(); }
		setMsg("Hotkey sent", "ok");
	} catch (e) {
		setMsg("Sending hotkey failed", "err");
	} finally {
		hotkeyButtons.forEach(b => b.disabled = false);
	}
}

// Send on click (preserve spaces and CR/LF exactly)
btn.addEventListener("click", function() {
	const value = text.value;
	if (value === undefined || value === null) {
		setMsg("Text field missing", "err");
		return;
	}
	sendText(value);
});

// NEW: Enter to send, Shift+Enter for newline
text.addEventListener("keydown", function(e) {
	if (e.key === "Enter" && !e.shiftKey) {
		e.preventDefault();     // don't insert newline
		btn.click();            // trigger send
	}
});

/* NEW: wire hotkey buttons */
btnCtrlC.addEventListener("click", () => sendRaw(CTRL_C));
btnCtrlX.addEventListener("click", () => sendRaw(CTRL_X));
btnCtrlAltDel.addEventListener("click", () => sendRaw(CAD_SEQUENCE));

function maskAndShorten(s) {
	if (!s) { return ""; }
	return "•".repeat(Math.min(s.length, 24)) + (s.length > 24 ? "…" : "");
}

function shorten(s) {
  if (!s) { return ""; }
  return s.slice(0, 24) + (s.length > 24 ? "…" : "");
}

function renderList(presets) {
	plist.innerHTML = "";

	const names = Object.keys(presets).sort(function(a, b) { return a.localeCompare(b); });

	if (names.length === 0) {
		plist.innerHTML = '<div class="small">No presets yet</div>';
		return;
	}

	for (const n of names) {
		let entry = presets[n];

		const row = document.createElement("div");
		row.className = "kv";

		const nameEl = document.createElement("div");
		nameEl.className = "name";
		nameEl.textContent = n;

		const vals = document.createElement("div");
		vals.className = "vals";

		const userEl = document.createElement("div");
		userEl.className = "val small";
		userEl.textContent = shorten(entry.user || "");

		const passEl = document.createElement("div");
		passEl.className = "val small val--clip";
		let shown = false;
		const passText = document.createElement("span");
		passText.textContent = maskAndShorten(entry.pass || "");
		const toggle = document.createElement("span");
		toggle.className = "toggle";
		toggle.textContent = "show";
		toggle.addEventListener("click", function() {
			shown = !shown;
			passText.textContent = shown ? shorten(entry.pass || "") : maskAndShorten(entry.pass || "");
			toggle.textContent = shown ? "hide" : "show";
		});
		passEl.appendChild(passText);
		passEl.appendChild(document.createTextNode(" "));
		passEl.appendChild(toggle);

		const actions = document.createElement("div");
		actions.style.display = "flex";
		actions.style.gap = "10px";

		const sendUserBtn = document.createElement("button");
		sendUserBtn.className = "btn-sm";
		sendUserBtn.textContent = "Send User";
		sendUserBtn.addEventListener("click", function() {
			const v = entry.user || "";
			text.value = v;
			sendText(v);
		});

		const sendPassBtn = document.createElement("button");
		sendPassBtn.className = "btn-sm";
		sendPassBtn.textContent = "Send Pass";
		sendPassBtn.addEventListener("click", function() {
			const v = entry.pass || "";
			text.value = v;
			sendText(v);
		});

		const delBtn = document.createElement("button");
		delBtn.className = "btn-sm";
		delBtn.textContent = "Delete";
		delBtn.addEventListener("click", async function() {
			if (!confirm('Delete preset "' + n + '"?')) { return; }
			try {
				const r = await fetch("/presets?name=" + encodeURIComponent(n), { method: "DELETE" });
				if (!r.ok) { throw new Error(); }
				await loadPresets();
				setMsg("Delete successful", "ok");
			} catch (e) {
				setMsg("Delete failed", "err");
			}
		});

		actions.appendChild(sendUserBtn);
		actions.appendChild(sendPassBtn);
		actions.appendChild(delBtn);

		vals.appendChild(userEl);
		vals.appendChild(passEl);
		vals.appendChild(actions);

		row.appendChild(nameEl);
		row.appendChild(vals);

		plist.appendChild(row);
	}
}

async function loadPresets() {
	try {
		const r = await fetch("/presets");
		if (!r.ok) { throw new Error(); }
		const data = await r.json();
		renderList(data);
	} catch (e) {
		setMsg("Failed to load presets", "err");
	}
}

addBtn.addEventListener("click", async function() {
	const n = pname.value.trim();
	const u = puser.value;
	const p = ppass.value;

	if (!n) {
		setMsg("Name is required", "warn");
		return;
	}

	addBtn.disabled = true;

	try {
		const body =
			"name=" + encodeURIComponent(n) +
			"&user=" + encodeURIComponent(u) +
			"&pass=" + encodeURIComponent(p);

		const r = await fetch("/presets", {
			method: "POST",
			headers: { "Content-Type": "application/x-www-form-urlencoded" },
			body
		});

		if (!r.ok) { throw new Error(); }

		pname.value = "";
		puser.value = "";
		ppass.value = "";

		await loadPresets();
		setMsg("Saving successful", "ok");
	} catch (e) {
		setMsg("Saving failed", "err");
	} finally {
		addBtn.disabled = false;
	}
});

loadPresets();
</script>
</body>
</html>
